# PRNG Exploit using CREATE2

This repo and accompanying contracts explore how `CREATE2` (or the newer Salted Contract Creations) can be used to exploit contracts that make use of pseudorandom number generators (PRNG).

Credit to Roberto, a security engineer at Halborn Security, who originally showed me this type of exploit.

```
                ┌──────────┐                         ┌──────────┐
                │          │      ┌ ─ ─ ─ ─ ─        │          │
┌────────┐      │          │                 │       │          │
│        │      │   PRNG   │      │ Exploit          │   PRNG   │
│  EOA   │─────▶│ Attacker │─ ─ ─▶  Contract │──────▶│  Victim  │
│        │      │ Contract │      │                  │ Contract │
└────────┘      │          │                 │       │          │
                │          │      └ ─ ─ ─ ─ ─        │          │
                └──────────┘                         └──────────┘

```

## A Disclaimer

This is just an experiment, a proof of concept intended for demonstration purposes, and is by no means a best practise or intended to be used or implemented to exploit existing contracts. The victim contract has been designed in such a way as to allow for this type of exploit, simply to demonstrate the method. If you do discover a vulnerability in someone's contracts, report the vulnerability responsibly.

## The Scenario

In this hypothetical scenario, an NFT collection is being created using Openzeppelin's ERC721 implementation (`src/PrgnVictim.sol`). The project creator has decided that they want to reveal the project's metadata before the mint as an attempt to boost interest in the project. To protect against nefarious actors, or snipers, minting rare tokens, they've implemented a commonly used pattern that assigns a token ID at the time of mint, using the entropy generated by a pseudorandom number generator (PRNG).

Unminted token IDs are tracked in a fixed-length array. Tracking unminted IDs is beyond the scope of this experiment, but there's an in-depth breakdown of this technique available [here](https://www.justinsilver.com/technology/cryptocurrency/nft-mint-random-token-id/_) if you'd like to learn more.

A nefarious actor (`Attacker EOA`) will deploy an exploit factory (`src/PrngAttacker.sol`) that will accurately predict the desired contract address for minting rare tokens, then deploy an `Exploit` contract to said address and mint said tokens.

## The exploit

In order for this exploit to be successful, the attacker relies on certain conditions:

-   a weak PRNG that uses globally available variables (eg. `block.timestamp`, `block.basefee`, `msg.sender` etc)
-   knowing which token IDs are valuable ahead of time
-   the victim contract allows transactions from smart contracts
-   the ultimate value of the rare tokens exceeds the gas necessary to mint them via the exploit
-   the variables used to determine the random token IDs are externally accessible, ie. `uint256[maxSupply] public tokenIds;` and `uint256 public count;`.

The Victim contract's developer thought they were being clever and included `msg.sender` and `address(this)` (the address of the victim contract's own account) when generating the `entropy`. They posited that this made the randomness "secure" because using `block.*` values alone would be open to manipulation by miners.

The key to this exploit is predicting what the random token ID will be at the time of mint. If the Victim's PRNG did not include `msg.sender`, this would be trivial. However, the inclusion of `msg.sender` means that our Attacker contract will need to predict the address of the `Exploit` contract that it deploys.

Because the Victim contract's project owner released the metadata ahead of time, the attacker is able to ascertain the token IDs of the 10 rarest tokens and store them in a `uint256[10] rareTokenIds` array (again this is a hypothetical scenario).

The exploit unfolds as follows:

1. The Attacker EOA calls the `exploitVictim` fn on the `PrngAttackerFactory`, passing in the number of iterations to go through.
1. The Attacker Factory enters a loop, using the index of each iteration to create the `salt` that will be used to predict the iteration's address should the `Exploit` contract be deployed.
1. The internal `_emulateVictimPrng` fn takes care of predicting the tokenID using the same values that the Victim would.
1. Before attempting to emulate the PRNG's outcome, the predicted address is generated using the address of the creating contract, the provided `salt`, the creation bytecode of the created contract, and the constructor args passed to it. The `keccak256` hash of the resulting bytes are then cast to a `uint256`, which in turn is cast to a `uint160` (taking only the necessary 20bytes) and then cast to an `address`.
1. The predicted address and the target contracts address are used in conjuction with the global variables used for the entropy generation (these will be shared between the Victim and Attacker factory because they form part of the same transaction, ie they share the `block`).
1. Once the tokenId has been determined, it's checked against the values stored in the `rareTokenIds` array. If the `computedTokenId` is rare, the `deployExploitContract` fn is called.
1. An `Exploit` contract is deployed using the `Salted Contract Creation` method, passing in the `salt` generated for the specific iteration of the loop, as well as the same constructor args that were used to generate the bytecode when deriving the address.
1. At the time of its creation the `Exploit` contract calls the `mintRandom` fn in the constructor. The end result is that the `computedTokenId` in the Attacker Factory will match the actual token ID minted to the Exploit.
1. The attacker EOA can then withdraw the rare token at their leisure.

## Testing

A simple implementation is available in the `test/PrngExploit.t.sol` file. The contracts emit events that help document the process, and the tests themselves include console logs. Including the `-vvvv` flag with forge will make these visible.

To view the results, just run:

```
forge test -vvvv --gas-report
```

## Reference

-   [Solidity Docs: Salted contract creations / create2](https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2)
-   [Solidity by Example: Precompute Contract addrress with Create2](https://solidity-by-example.org/app/create2/)
