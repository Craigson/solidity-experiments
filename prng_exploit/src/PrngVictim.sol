// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

import "openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";

import {console} from "forge-std/console.sol";

contract PrngVictim is ERC721 {
    // CONSTANTS
    uint256 private constant PRICE_PER_TOKEN = 0.1 ether;
    uint256 private constant MAX_PER_TX = 2;
    uint256 public constant maxSupply = 1000;

    uint256[maxSupply] public tokenIds; // size matches total supply
    uint256 public count;

    event RandomMint(address indexed to, uint256 id);

    constructor() ERC721("Victim", "PRNGV") {}

    function mintRandom(uint256 numTokens) external payable {
        require(msg.value >= numTokens * PRICE_PER_TOKEN, "!insufficient");
        require(numTokens <= MAX_PER_TX, "!tooMany");
        for (uint256 i; i < numTokens; i++) {
            uint256 tokenId = _pickRandomTokenID();
            _mint(msg.sender, tokenId);
            emit RandomMint(msg.sender, tokenId);
        }
    }

    function _pickRandomTokenID() internal returns (uint256 id) {
        // create entropy for the PRNG. Include `msg.sender` and address(this) to prevent
        // manipulation by miners.
        uint256 entropy = uint256(
            keccak256(
                abi.encode(
                    msg.sender,
                    address(this),
                    blockhash(block.number - 1),
                    block.basefee,
                    block.timestamp
                )
            )
        );

        uint256 numTokensRemaining = tokenIds.length - count++;
        require(numTokensRemaining > 0, "!empty");

        uint256 randomcount = entropy % numTokensRemaining;
        id = tokenIds[randomcount] != 0 ? tokenIds[randomcount] : randomcount;
        tokenIds[randomcount] = uint256(
            tokenIds[numTokensRemaining - 1] == 0
                ? numTokensRemaining - 1
                : tokenIds[numTokensRemaining - 1]
        );
        tokenIds[numTokensRemaining - 1] = 0;
    }
}
